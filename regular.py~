
class Regular():

    def __init__(self):
        x_max = 400
        y_max = 400

        cut_along_x = int(input("Enter block size along x"))
        cut_along_y = int(input("Enter block size along y"))

        x_scale = range(cut_along_x, x_max, cut_along_x) + x_max
        y_scale = range(cut_along_y, y_max, cut_along_y) + y_max

    def insert(self, id, x, y):
        pass

    def get_all_els(self, x, y):
        pass

    def get_all_els(self, block_number):
        pass
	
	# this function gives indices for a point, of the cell it is in
def give_indices_of_2dcell(self):
		i=0;j=0
		while j < len(self.x_scale):
		    if x <= self.x_scale[j]:
		        break
		    j+=1

		while i < len(self.y_scale):
		    if y <= self.y_scale[i]:
		        break
		    i+=1

		return (i,j)
		
	def get_cell_no(self, index_i, index_j):
		cell_no = (len(self.x_scale) * index_i) + index_j
		return cell_no
		
	def get_x_y_for_euclidian_dist(self, query_i, query_j, cell_i, cell_j):

		if query_i == cell_i:

		    if query_j < cell_j:
		        if cell_i == 0:
		            y_point = self.y_scale[cell_i]/2
		        else:
		            y_point=(self.y_scale[cell_i-1]+self.y_scale[cell_i])/2
		            x_point=self.x_scale[cell_j-1];

		    elif query_j > cell_j:
		        if cell_i == 0:
		            y_point = self.y_scale[cell_i]/2
		        else:
		            x_point=self.x_scale[cell_j]
		            y_point=(self.y_scale[cell_i-1] + self.y_scale[cell_i])/2

		elif query_j == cell_j:

		    if query_i > cell_i:
		        if cell_j == 0:
		            x_point = self.x_scale[cell_j]/2
		        else:
		            x_point=(self.x_scale[cell_j] + self.x_scale[cell_j-1])/2
		            y_point=self.y_scale[cell_i]

		    elif query_i < cell_i:
		        if cell_j == 0:
		            x_point = self.x_scale[cell_j]/2
		        else:
		            x_point=(self.x_scale[cell_j] + self.x_scale[cell_j-1])/2
		            y_point=self.y_scale[cell_i-1]

		elif query_i < cell_i:

		    if query_j < cell_j:
		        x_point = self.x_scale[cell_j-1]
		        y_point = self.y_scale[cell_i-1]

		    elif query_j > cell_j:
		        x_point = self.x_scale[cell_j]
		        y_point = self.y_scale[cell_i-1]

		elif query_i > cell_i:

		    if query_j < cell_j:
		        x_point = self.x_scale[cell_j-1]
		        y_point = self.y_scale[cell_i]

		    elif query_j > cell_j:
		        x_point = self.x_scale[cell_j]
		        y_point = self.y_scale[cell_i]
		return (x_point, y_point)
	
	def get_euclidian_dist(self, query_x, query_y, data_x, data_y):
    	return math.sqrt(math.pow((data_x-query_x),2) + math.pow((data_y-query_y),2))
    	
    ''' cycle returns a list of tuples [(cell_no, euclidean_dist),()...]
    takes input as x and y for query point and
    c for cycle no.

	'''
	def cycle(self, query_x, query_y, cycle_no):
		cycle = []

		index_i, index_j = give_indices_of_2dcell(query_x, query_y)
		cycle_cell_i, cycle_cell_j = index_i, index_j + cycle_no

		if cycle_cell_i in range(len(self.y_scale)) and cycle_cell_j in range(len(self.x_scale)):
		    cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)

		    euclidian_dist = get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		    cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		    cycle.append((cell_no, euclidian_dist))

		for i in range(1,cycle_no*8):
		    if i<=cycle_no:
		        cycle_cell_i -= 1

		        if cycle_cell_i not in range(len(self.y_scale)) or cycle_cell_j not in range(len(self.x_scale)):
		            continue

		        cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)
		        euclidian_dist =  get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		        cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		        cycle.append((cell_no, euclidian_dist))


		    elif i>cycle_no and i <= (3*cycle_no):
		        cycle_cell_j -= 1

		        if cycle_cell_i not in range(len(self.y_scale)) or cycle_cell_j not in range(len(self.x_scale)):
		            continue
		        cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)
		        euclidian_dist =  get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		        cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		        cycle.append((cell_no, euclidian_dist))

		    elif i > (3*cycle_no) and i <=  (5*cycle_no):
		        cycle_cell_i += 1

		        if cycle_cell_i not in range(len(self.y_scale)) or cycle_cell_j not in range(len(self.x_scale)):
		            continue

		        cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)
		        euclidian_dist =  get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		        cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		        cycle.append((cell_no, euclidian_dist))

		    elif i > (5*cycle_no) and i <=  (7*cycle_no):
		        cycle_cell_j += 1

		        if cycle_cell_i not in range(len(self.y_scale)) or cycle_cell_j not in range(len(self.x_scale)):
		            continue

		        cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)
		        euclidian_dist =  get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		        cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		        cycle.append((cell_no, euclidian_dist))

		    elif i  > 7*cycle_no:
		        cycle_cell_i -= 1

		        if cycle_cell_i not in range(len(self.y_scale)) or cycle_cell_j not in range(len(self.x_scale)):
		            continue

		        cycle_cell_x, cycle_cell_y = get_x_y_for_euclidian_dist(index_i, index_j, cycle_cell_i, cycle_cell_j)
		        euclidian_dist =  get_euclidian_dist(query_x, query_y, cycle_cell_x, cycle_cell_y)
		        cell_no = get_cell_no(cycle_cell_i, cycle_cell_j)

		        cycle.append((cell_no, euclidian_dist))
		return cycle


reg=Rugular()



